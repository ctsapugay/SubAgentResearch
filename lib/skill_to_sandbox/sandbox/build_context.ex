defmodule SkillToSandbox.Sandbox.BuildContext do
  @moduledoc """
  Assembles a Docker build context directory from a `%SandboxSpec{}`.

  Creates a temporary directory containing:
  - `Dockerfile` -- generated by `DockerfileBuilder`
  - Dependency files (`package.json` for npm, `requirements.txt` for pip, etc.)
  - `tools/` directory with shell scripts for each tool
  - `tool_manifest.json` -- machine-readable tool descriptions

  The caller is responsible for cleaning up via `cleanup/1` after the
  Docker build completes.
  """

  require Logger

  alias SkillToSandbox.Analysis.SandboxSpec
  alias SkillToSandbox.Sandbox.DockerfileBuilder
  alias SkillToSandbox.Tools.Manifest

  @tool_modules Manifest.tool_modules()

  @doc """
  Assemble a complete Docker build context directory.

  Returns `{:ok, context_dir_path}` on success or `{:error, reason}` on failure.
  The returned path is a temporary directory that should be cleaned up with `cleanup/1`.
  """
  def assemble(%SandboxSpec{} = spec) do
    dir = build_dir_path()
    File.mkdir_p!(dir)

    try do
      # 1. Generate and write the Dockerfile
      dockerfile_content = DockerfileBuilder.build(spec)
      File.write!(Path.join(dir, "Dockerfile"), dockerfile_content)

      # 2. Write dependency files (package.json, requirements.txt, etc.)
      write_dependency_files(dir, spec)

      # 3. Write tool scripts into tools/ subdirectory
      write_tool_scripts(dir)

      # 4. Write tool manifest
      File.write!(Path.join(dir, "tool_manifest.json"), Manifest.generate())

      Logger.info("[BuildContext] Assembled build context at #{dir}")

      {:ok, dir, dockerfile_content}
    rescue
      e ->
        Logger.error("[BuildContext] Assembly failed: #{Exception.message(e)}")
        # Best-effort cleanup on failure
        cleanup(dir)
        {:error, Exception.message(e)}
    end
  end

  @doc """
  Remove a build context directory and all its contents.
  """
  def cleanup(dir) when is_binary(dir) do
    if File.exists?(dir) do
      File.rm_rf!(dir)
      Logger.debug("[BuildContext] Cleaned up #{dir}")
    end

    :ok
  end

  @doc """
  List all files in a build context directory (for inspection/debugging).
  Returns a list of relative paths.
  """
  def list_files(dir) when is_binary(dir) do
    dir
    |> Path.join("**/*")
    |> Path.wildcard()
    |> Enum.filter(&File.regular?/1)
    |> Enum.map(&Path.relative_to(&1, dir))
    |> Enum.sort()
  end

  # -- Private --

  defp build_dir_path do
    unique = :erlang.unique_integer([:positive])
    Path.join(System.tmp_dir!(), "sandbox_build_#{unique}")
  end

  defp write_dependency_files(dir, %SandboxSpec{} = spec) do
    for {relative_path, content} <- DockerfileBuilder.required_context_files(spec) do
      full_path = Path.join(dir, relative_path)
      # Ensure parent dir exists (for nested paths)
      full_path |> Path.dirname() |> File.mkdir_p!()
      File.write!(full_path, content)
    end
  end

  defp write_tool_scripts(dir) do
    tools_dir = Path.join(dir, "tools")
    File.mkdir_p!(tools_dir)

    for tool <- @tool_modules do
      script_path = Path.join(tools_dir, "#{tool.name()}.sh")
      File.write!(script_path, tool.container_setup_script())
      # Make executable
      File.chmod!(script_path, 0o755)
    end
  end
end
